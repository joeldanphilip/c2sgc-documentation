#include <stdio.h>
#include <stdint.h>

// ==========================================
// 1. HARDWARE ADDRESSES
// ==========================================
#define UART_BASE     0x10001000UL // Your UART Address
#define SPI_BASE      0x10002000UL
#define I2C_BASE      0x10003000UL

#define REG32(addr)   (*(volatile uint32_t *)(addr))

// ==========================================
// 2. CONSTANTS
// ==========================================
#define ARDUCHIP_TEST1       0x00
#define ARDUCHIP_FIFO        0x04
#define ARDUCHIP_TRIG        0x41
#define CAP_DONE_MASK        0x08
#define ARDUCHIP_FIFO_SIZE1  0x42
#define ARDUCHIP_FIFO_SIZE2  0x43
#define ARDUCHIP_FIFO_SIZE3  0x44
#define BURST_FIFO_READ      0x3C
#define OV2640_ADDR          0x30

// ==========================================
// 3. LOW-LEVEL DRIVERS
// ==========================================
void delay_loop(int count) {
    for(volatile int i=0; i<count; i++);
}

// --- UART DRIVER (The Critical Fix) ---
void uart_init_safe() {
    REG32(UART_BASE + 0x04) = 0x00; // Disable Interrupts
}

char uart_read_safe() {
    while ((REG32(UART_BASE + 0x14) & 0x01) == 0); // Wait Data Ready
    return (char)(REG32(UART_BASE + 0x00) & 0xFF);
}

void uart_write_raw(uint8_t data) {
    // Wait for Transmitter Holding Register Empty (Bit 5 of LSR)
    // This ensures we don't overwrite data being sent
    while ((REG32(UART_BASE + 0x14) & 0x20) == 0);
    
    // Write directly to HW, bypassing standard library newline conversion
    REG32(UART_BASE + 0x00) = data;
}

// --- SPI DRIVER ---
void spi_init() {
    REG32(SPI_BASE + 0x40) = 0x0A; 
    delay_loop(10000);
    REG32(SPI_BASE + 0x60) = 0x186; 
    REG32(SPI_BASE + 0x70) = 0xFFFFFFFF; 
}

uint8_t spi_transfer(uint8_t data) {
    REG32(SPI_BASE + 0x68) = data;
    REG32(SPI_BASE + 0x60) &= ~0x100;
    while((REG32(SPI_BASE + 0x64) & 0x01) != 0);
    return (uint8_t)REG32(SPI_BASE + 0x6C);
}

void arducam_write_reg(uint8_t addr, uint8_t data) {
    REG32(SPI_BASE + 0x70) = 0xFFFFFFFE;
    spi_transfer(addr | 0x80);
    spi_transfer(data);
    REG32(SPI_BASE + 0x70) = 0xFFFFFFFF;
    delay_loop(1000);
}

uint8_t arducam_read_reg(uint8_t addr) {
    REG32(SPI_BASE + 0x70) = 0xFFFFFFFE;
    spi_transfer(addr & 0x7F);
    uint8_t val = spi_transfer(0x00);
    REG32(SPI_BASE + 0x70) = 0xFFFFFFFF;
    delay_loop(1000);
    return val;
}

// --- I2C DRIVER ---
void i2c_init() {
    REG32(I2C_BASE + 0x40) = 0x0A; 
    delay_loop(1000);
    REG32(I2C_BASE + 0x100) = 0x01; 
}

void i2c_write_reg(uint8_t reg, uint8_t val) {
    REG32(I2C_BASE + 0x40) = 0x0A;
    delay_loop(500); 
    REG32(I2C_BASE + 0x100) = 0x01;
    
    REG32(I2C_BASE + 0x108) = 0x100 | (OV2640_ADDR << 1);
    REG32(I2C_BASE + 0x108) = reg;
    REG32(I2C_BASE + 0x108) = 0x200 | val;
    
    int timeout = 0;
    while((REG32(I2C_BASE + 0x104) & 0x80) == 0) {
        if(++timeout > 1000000) { printf("[FAIL] I2C Timeout\n"); return; }
    }
    delay_loop(5000);
}

// ==========================================
// 4. CONFIG ARRAYS
// ==========================================
const uint8_t OV2640_JPEG_INIT[][2] = {
    {0xff, 0x00}, {0x2c, 0xff}, {0x2e, 0xdf}, {0xff, 0x01}, {0x3c, 0x32}, {0x11, 0x00},
    {0x09, 0x02}, {0x04, 0x28}, {0x13, 0xe5}, {0x14, 0x48}, {0x2c, 0x0c}, {0x33, 0x78},
    {0x3a, 0x33}, {0x3b, 0xfb}, {0x3e, 0x00}, {0x43, 0x11}, {0x16, 0x10}, {0x39, 0x92},
    {0x35, 0xda}, {0x22, 0x1a}, {0x37, 0xc3}, {0x23, 0x00}, {0x34, 0xc0}, {0x36, 0x1a},
    {0x06, 0x88}, {0x07, 0xc0}, {0x0d, 0x87}, {0x0e, 0x41}, {0x4c, 0x00}, {0x48, 0x00},
    {0x5b, 0x00}, {0x42, 0x03}, {0x4a, 0x81}, {0x21, 0x99}, {0x24, 0x40}, {0x25, 0x38},
    {0x26, 0x82}, {0x5c, 0x00}, {0x63, 0x00}, {0x61, 0x70}, {0x62, 0x80}, {0x7c, 0x05},
    {0x20, 0x80}, {0x28, 0x30}, {0x6c, 0x00}, {0x6d, 0x80}, {0x6e, 0x00}, {0x70, 0x02},
    {0x71, 0x94}, {0x73, 0xc1}, {0x12, 0x40}, {0x17, 0x11}, {0x18, 0x43}, {0x19, 0x00},
    {0x1a, 0x4b}, {0x32, 0x09}, {0x37, 0xc0}, {0x4f, 0x60}, {0x50, 0xa8}, {0x6d, 0x00},
    {0x3d, 0x38}, {0x46, 0x3f}, {0x4f, 0x60}, {0x0c, 0x3c}, {0xff, 0x00}, {0xe5, 0x7f},
    {0xf9, 0xc0}, {0x41, 0x24}, {0xe0, 0x14}, {0x76, 0xff}, {0x33, 0xa0}, {0x42, 0x20},
    {0x43, 0x18}, {0x4c, 0x00}, {0x87, 0xd5}, {0x88, 0x3f}, {0xd7, 0x03}, {0xd9, 0x10},
    {0xd3, 0x82}, {0xc8, 0x08}, {0xc9, 0x80}, {0x7c, 0x00}, {0x7d, 0x00}, {0x7c, 0x03},
    {0x7d, 0x48}, {0x7d, 0x48}, {0x7c, 0x08}, {0x7d, 0x20}, {0x7d, 0x10}, {0x7d, 0x0e},
    {0x90, 0x00}, {0x91, 0x0e}, {0x91, 0x1a}, {0x91, 0x31}, {0x91, 0x5a}, {0x91, 0x69},
    {0x91, 0x75}, {0x91, 0x7e}, {0x91, 0x88}, {0x91, 0x8f}, {0x91, 0x96}, {0x91, 0xa3},
    {0x91, 0xaf}, {0x91, 0xc4}, {0x91, 0xd7}, {0x91, 0xe8}, {0x91, 0x20}, {0x92, 0x00},
    {0x93, 0x06}, {0x93, 0xe3}, {0x93, 0x05}, {0x93, 0x05}, {0x93, 0x00}, {0x93, 0x04},
    {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00},
    {0x93, 0x00}, {0x96, 0x00}, {0x97, 0x08}, {0x97, 0x19}, {0x97, 0x02}, {0x97, 0x0c},
    {0x97, 0x24}, {0x97, 0x30}, {0x97, 0x28}, {0x97, 0x26}, {0x97, 0x02}, {0x97, 0x98},
    {0x97, 0x80}, {0x97, 0x00}, {0x97, 0x00}, {0xc3, 0xed}, {0xa4, 0x00}, {0xa8, 0x00},
    {0xc5, 0x11}, {0xc6, 0x51}, {0xbf, 0x80}, {0xc7, 0x10}, {0xb6, 0x66}, {0xb8, 0xa5},
    {0xb7, 0x64}, {0xb9, 0x7c}, {0xb3, 0xaf}, {0xb4, 0x97}, {0xb5, 0xff}, {0xb0, 0xc5},
    {0xb1, 0x94}, {0xb2, 0x0f}, {0xc4, 0x5c}, {0xc0, 0x64}, {0xc1, 0x4b}, {0x8c, 0x00},
    {0x86, 0x3d}, {0x50, 0x00}, {0x51, 0xc8}, {0x52, 0x96}, {0x53, 0x00}, {0x54, 0x00},
    {0x55, 0x00}, {0x5a, 0xc8}, {0x5b, 0x96}, {0x5c, 0x00}, {0xd3, 0x00}, {0xc3, 0xed},
    {0x7f, 0x00}, {0xda, 0x00}, {0xe5, 0x1f}, {0xe1, 0x67}, {0xe0, 0x00}, {0xdd, 0x7f},
    {0x05, 0x00}, {0x12, 0x40}, {0xd3, 0x04}, {0xc0, 0x16}, {0xc1, 0x12}, {0x8c, 0x00},
    {0x86, 0x3d}, {0x50, 0x00}, {0x51, 0x2c}, {0x52, 0x24}, {0x53, 0x00}, {0x54, 0x00},
    {0x55, 0x00}, {0x5a, 0x2c}, {0x5b, 0x24}, {0x5c, 0x00}, {0xff, 0xff}
};

const uint8_t OV2640_320x240_JPEG[][2] = {
    {0xff, 0x01}, {0x12, 0x40}, {0x17, 0x11}, {0x18, 0x43}, {0x19, 0x00}, {0x1a, 0x4b},
    {0x32, 0x09}, {0x4f, 0xca}, {0x50, 0xa8}, {0x5a, 0x23}, {0x6d, 0x00}, {0x39, 0x12},
    {0x35, 0xda}, {0x22, 0x1a}, {0x37, 0xc3}, {0x23, 0x00}, {0x34, 0xc0}, {0x36, 0x1a},
    {0x06, 0x88}, {0x07, 0xc0}, {0x0d, 0x87}, {0x0e, 0x41}, {0x4c, 0x00}, {0xff, 0x00},
    {0xe0, 0x04}, {0xc0, 0x64}, {0xc1, 0x4b}, {0x86, 0x35}, {0x50, 0x89}, {0x51, 0xc8},
    {0x52, 0x96}, {0x53, 0x00}, {0x54, 0x00}, {0x55, 0x00}, {0x57, 0x00}, {0x5a, 0x50},
    {0x5b, 0x3c}, {0x5c, 0x00}, {0xe0, 0x00}, {0xff, 0xff}
};

void sensor_write_array(const uint8_t data[][2]) {
    int i = 0;
    while (1) {
        uint8_t reg = data[i][0];
        uint8_t val = data[i][1];
        if (reg == 0xFF && val == 0xFF) break;
        i2c_write_reg(reg, val);
        i++;
    }
}

// ==========================================
// 5. MAIN LOOP
// ==========================================
int main() {
    uart_init_safe();
    spi_init();
    i2c_init();

    printf("\n\n[VEGA] No-Corruption Master\n");

    // 1. SPI
    printf("1. Check SPI... ");
    arducam_write_reg(ARDUCHIP_TEST1, 0x55);
    if(arducam_read_reg(ARDUCHIP_TEST1) == 0x55) printf("[PASS]\n");
    else { printf("[FAIL]\n"); return -1; }

    // 2. Config
    printf("2. Configuring... ");
    i2c_write_reg(0xFF, 0x01); 
    i2c_write_reg(0x12, 0x80); 
    delay_loop(100000);
    sensor_write_array(OV2640_JPEG_INIT);
    sensor_write_array(OV2640_320x240_JPEG);
    printf("[DONE]\n");

    // 3. Loop
    while (1) {
        printf("\n[READY] Waiting for 'c'...\n");
        char cmd = uart_read_safe();
        
        if (cmd == 'c') {
            printf("[CMD] Capture!\n");
            
            arducam_write_reg(ARDUCHIP_FIFO, 0x01); 
            arducam_write_reg(ARDUCHIP_FIFO, 0x02); 
            
            int attempts = 0;
            while (!(arducam_read_reg(ARDUCHIP_TRIG) & CAP_DONE_MASK)) {
                delay_loop(100000);
                if(++attempts > 500) break;
            }
            
            if (attempts <= 500) {
                uint32_t len1 = arducam_read_reg(ARDUCHIP_FIFO_SIZE1);
                uint32_t len2 = arducam_read_reg(ARDUCHIP_FIFO_SIZE2);
                uint32_t len3 = arducam_read_reg(ARDUCHIP_FIFO_SIZE3) & 0x7F;
                uint32_t length = ((len3 << 16) | (len2 << 8) | len1) & 0x07FFFFF;

                printf("Size: %d bytes\n", (int)length);
                printf("--- START JPEG ---\n");

                REG32(SPI_BASE + 0x70) = 0xFFFFFFFE; 
                spi_transfer(BURST_FIFO_READ);
                
                for (uint32_t i = 0; i < length; i++) {
                    uint8_t byte = spi_transfer(0x00);
                    
                    // THIS IS THE FIX:
                    // Use custom raw writer instead of putchar()
                    uart_write_raw(byte); 
                }
                REG32(SPI_BASE + 0x70) = 0xFFFFFFFF; 
                
                printf("\n--- END JPEG ---\n");
            }
        }
    }
    return 0;
}
